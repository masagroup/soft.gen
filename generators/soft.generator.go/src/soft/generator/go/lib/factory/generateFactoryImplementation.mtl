[comment encoding = UTF-8 /]
[module generateFactoryImplementation('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::common::generateCommon/]
[import soft::generator::go::generateCommon/]
[import soft::generator::go::generateType/]
[import soft::generator::go::lib::generateCommon/]
[import soft::generator::go::lib::factory::generateCommon/]

[template public generateFactoryImplementation(anEPackage : EPackage) { className : String = anEPackage.getFactoryImplementationName() ; }]
[file (anEPackage.getOutputDirectory() + '/' + anEPackage.getImplementationFileName(anEPackage.getFactoryName() ), false, 'UTF-8')]
[fileComment()/]

package [anEPackage.name/]

import "strconv"
[if not anEPackage.isEcorePackage()]
import "[anEPackage.getImportForPackage('ecore')/]"
[/if]
type [anEPackage.getFactoryInternalName()/] interface {
[let dataTypes : Sequence(EDataType) = anEPackage.eAllContents(EDataType)->select( serializable )->sortedBy(name)]
[for (aDataType : EDataType | dataTypes)]
    create[aDataType.name/]FromString(eDataType [if not anEPackage.isEcorePackage()]ecore.[/if]EDataType, literalValue string) interface{}
[/for]
[for (aDataType : EDataType | dataTypes)]
    convert[aDataType.name/]ToString(eDataType [if not anEPackage.isEcorePackage()]ecore.[/if]EDataType, literalValue interface{}) string
[/for]
[/let]
}

type [className/] struct {
    *[if not anEPackage.isEcorePackage()]ecore.[/if]EFactoryExt
}

func new[className.toUpperFirst()/]() *[className/] {
    factory := new([className/])
    factory.EFactoryExt = NewEFactoryExt()
    factory.interfaces = factory
    return factory 
}

[anEPackage.generateFactoryImplementationMember()/] Create(eClass [if not anEPackage.isEcorePackage()]ecore.[/if]EClass) [if not anEPackage.isEcorePackage()]ecore.[/if]EObject {
	classID := eClass.GetClassifierID()
	switch classID {
    [for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) ? (aClass.abstract=false)]
    case [aClass.getClassifierIDName()/]:
        return [anEPackage.getFactoryReceiverName()/].Create[aClass.name/]()
    [/for]
    default:
        panic("Create: " + strconv.Itoa( classID ) + " not found")
	}
}

[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) ? (aClass.abstract=false)]
[anEPackage.generateFactoryImplementationMember()/] Create[aClass.name/]() [aClass.getInterfaceName()/] {
	return [if aClass.hasExtension()][aClass.getConstructorExtensionName()/][else][aClass.getConstructorName()/][/if]()
}
[let ref : OrderedSet(EReference) = aClass.getAllContainers()]
[for(aReference:EReference | ref->sortedBy(name))]
[anEPackage.generateFactoryImplementationMember()/] Create[aClass.name/]FromContainer(eContainer [aReference.eGenericType.eClassifier.name/]) [aClass.getInterfaceName()/] {
    [generateCreateFunctionContent(aClass, aReference, false)/]
}
[if(aClass.getElementIDAccessorName().size() > 0)]
[anEPackage.generateFactoryImplementationMember()/] Create[aClass.name/]FromContainerAndClassID(eContainer [aReference.eGenericType.eClassifier.name/], classID int) [aClass.getInterfaceName()/] {
    [generateCreateFunctionContent(aClass, aReference, true)/]
}
[/if]
[/for]
[/let]
[/for]
[let dataTypes : Sequence(EDataType) = anEPackage.eAllContents(EDataType)->select( serializable )->sortedBy(name)]
[anEPackage.generateFactoryImplementationMember()/] CreateFromString(eDataType [if not anEPackage.isEcorePackage()]ecore.[/if]EDataType, literalValue string) interface{} {
	classID  := eDataType.GetClassifierID()
    internal := [anEPackage.getFactoryReceiverName()/].interfaces.([anEPackage.getFactoryInternalName()/]) 
	switch classID {
    [for (aDataType : EDataType | dataTypes)]
    case [aDataType.getClassifierIDName()/]:
        return internal.create[aDataType.name/]FromString(eDataType, literalValue)
    [/for]
    default:
        panic("The datatype '" + eDataType.GetName() + "' is not a valid classifier")
	}
}

[anEPackage.generateFactoryImplementationMember()/] ConvertToString(eDataType [if not anEPackage.isEcorePackage()]ecore.[/if]EDataType, instanceValue interface{}) string {
    classID := eDataType.GetClassifierID()
    internal := [anEPackage.getFactoryReceiverName()/].interfaces.([anEPackage.getFactoryInternalName()/])
    switch classID {
[for (aDataType : EDataType | dataTypes)]
    case [aDataType.getClassifierIDName()/]:
        return internal.convert[aDataType.name/]ToString(eDataType, instanceValue)
[/for]
    default:
        panic("The datatype '" + eDataType.GetName() + "' is not a valid classifier")
    }
}
[for (aDataType : EDataType | dataTypes)]
[let createMethodName : String = 'create' + aDataType.name + 'FromString']
[anEPackage.generateFactoryImplementationMember()/] [createMethodName/](eDataType [if not anEPackage.isEcorePackage()]ecore.[/if]EDataType, literalValue string) interface{} {
	panic("NotImplementedException")
}
[/let]
[let convertMethodName : String = 'convert' + aDataType.name + 'ToString']
[anEPackage.generateFactoryImplementationMember()/] [convertMethodName/](eDataType [if not anEPackage.isEcorePackage()]ecore.[/if]EDataType, literalValue interface{}) string {
	panic("NotImplementedException")
}
[/let]
[/for]
[/let]

[/file]
[/template]

[template public generateCreateFunctionContent(aClass : EClass, aReference : EReference, addID : Boolean)]
element := [if aClass.hasExtension()][aClass.getConstructorExtensionName()/][else][aClass.getConstructorName()/][/if]()
[if(addID)]
element.Set[aClass.getElementIDAccessorName()/]ID(classID)
[/if]
[if(not aReference.eOpposite.name.oclIsUndefined())]
if eContainer != nil {
[if(aReference.eOpposite.upperBound <> 1)]
    eContainer.Get[aReference.eOpposite.name.toUpperFirst()/]().Add(element)
[else]
    eContainer.Set[aReference.eOpposite.name.toUpperFirst()/](element)
[/if]
}
[/if]
return element
[/template]
