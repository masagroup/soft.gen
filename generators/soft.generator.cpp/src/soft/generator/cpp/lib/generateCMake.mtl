[comment encoding = UTF-8 /]
[module generateCMake('http://www.eclipse.org/emf/2002/Ecore')/]

[import soft::generator::cpp::generateCommon/]
[import soft::generator::cpp::generateCMake/]
[import soft::generator::cpp::lib::generateCommon/]

[template public generateLibraryCMakeFiles(aPackage : EPackage) { packageName : String = aPackage.name;}]
[file (getOutputDirectory().concat('/CMakeGenerated.txt'), false, 'UTF-8')]
# Generated sources

[let namespaceVar : String = getVarName( aPackage.getInterfaceNamespaceName() )] 
set(GENERATED_HEADER_[namespaceVar/]_FILES
    src-gen/[packageName/]/Exports.hpp
    src-gen/[namespaceToFolder(aPackage.getFactoryQualifiedInterfaceName())/].hpp
    src-gen/[namespaceToFolder(aPackage.getQualifiedInterfaceName())/].hpp
[for (aClass : EClass | aPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name))]
    src-gen/[namespaceToFolder(aClass.getQualifiedInterfaceName())/].hpp
[/for]
)
set(GENERATED_SOURCE_[namespaceVar/]_FILES
    src-gen/[namespaceToFolder(aPackage.getFactoryQualifiedInterfaceName())/].cpp
    src-gen/[namespaceToFolder(aPackage.getQualifiedInterfaceName())/].cpp
)
[/let]
[let namespaceVar : String = getVarName( aPackage.getImplementationNamespaceName() )] 
set(GENERATED_HEADER_[namespaceVar/]_FILES
    src-gen/[namespaceToFolder(aPackage.getFactoryQualifiedBaseName())/].hpp
	src-gen/[namespaceToFolder(aPackage.getFactoryQualifiedBaseName())/].inl
    src-gen/[namespaceToFolder(aPackage.getFactoryQualifiedImplementationName())/].hpp
[for (aClass : EClass | aPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name))]
    src-gen/[namespaceToFolder(aClass.getQualifiedBaseName())/].hpp
    src-gen/[namespaceToFolder(aClass.getQualifiedBaseName())/].inl
    src-gen/[namespaceToFolder(aClass.getQualifiedImplementationName())/].hpp
[/for]
)
set(GENERATED_SOURCE_[namespaceVar/]_FILES    
[let packageImpl : String = namespaceToFolder(aPackage.getQualifiedImplementationName())]
    src-gen/[packageImpl/].cpp
    src-gen/[packageImpl/]_Creation.cpp
    src-gen/[packageImpl/]_Initialization.cpp
[/let]
)
[/let]

[/file]
[/template]

[template public generateLibraryCMakeLists(aPackage : EPackage) { packageName : String = aPackage.name;}]
[file (getOutputDirectory().concat('/CMakeLists.txt'), false, 'UTF-8')]
#############################################################################
#                                                                           #
#             CMakeList created by soft.generator.cpp Generator             # 
#                                                                           #
#############################################################################

# C++ project for model [packageName/].ecore, generated by soft.generator.cpp

CMAKE_MINIMUM_REQUIRED(VERSION 3.12)

project([packageName/] CXX)

if(NOT CMAKE_BUILD_TYPE) 
    set(CMAKE_BUILD_TYPE Debug)
endif()
set(CMAKE_DEBUG_POSTFIX d)

set(CMAKE_CXX_STANDARD 17)

include( CMakeFiles.txt OPTIONAL)
include( CMakeGenerated.txt OPTIONAL)

set(CMAKE_FILES
    CMakeLists.txt
)
if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/CMakeFiles.txt")
   list(APPEND CMAKE_FILES "CMakeFiles.txt")
endif()
if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/CMakeGenerated.txt")
   list(APPEND CMAKE_FILES "CMakeGenerated.txt")
endif()

[let namespaces : OrderedSet(String) = Sequence{ getAllNamespaces( aPackage.getInterfaceNamespaceName() ) 
                                               , getAllNamespaces( aPackage.getImplementationNamespaceName() )
                                               , getAllNamespaces( aPackage.getExtensionNamespaceName() )
                                               }->flatten()->asOrderedSet()->sortedBy(s | s)]
add_library(${PROJECT_NAME} STATIC  ${CMAKE_FILES}
[for (variable : String | namespaces->getAllVariables())]
                                    [variable/]
[/for]
)
target_include_directories(${PROJECT_NAME} PUBLIC src src-gen )
target_compile_options(${PROJECT_NAME} PRIVATE /MP /wd4250 /wd4251 ) 
set_target_properties(${PROJECT_NAME} PROPERTIES PREFIX "")

[generateSourceGroup(namespaces)/]

#-----------------------------------------------------
# Install binaries and header
#-----------------------------------------------------
install(TARGETS ${PROJECT_NAME} DESTINATION lib )
[for ( namespace : String | namespaces )]
[let namespaceVar : String = getVarName(namespace)]
install(FILES [getVarName('HEADER',namespaceVar,'FILES')/] [getVarName('GENERATED_HEADER',namespaceVar,'FILES')/] DESTINATION include[if namespace<>'']/[namespaceToFolder(namespace)/][/if])
[/let]
[/for]
[/let]


#-----------------------------------------------------
# Package binaries and header
#-----------------------------------------------------
set(CPACK_GENERATOR "ZIP")
set(CPACK_PACKAGE_NAME ${PROJECT_NAME})

include(CPack)

[/file]
[/template]


